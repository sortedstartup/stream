// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const checkUserAccess = `-- name: CheckUserAccess :one
SELECT 
    -- Subscription info
    s.user_id,
    s.plan_id,
    s.status as subscription_status,
    
    -- Plan limits
    p.storage_limit_bytes,
    p.api_calls_limit,
    p.compute_hours_limit,
    p.name as plan_name,
    p.price_cents,
    
    -- Current usage
    COALESCE(u.storage_used_bytes, 0) as current_storage_bytes,
    COALESCE(u.api_calls_used, 0) as current_api_calls,
    COALESCE(u.compute_hours_used, 0) as current_compute_hours,
    
    -- Access decision for storage
    CASE 
        WHEN s.status = 'active' 
         AND COALESCE(u.storage_used_bytes, 0) < p.storage_limit_bytes
        THEN 1 
        ELSE 0 
    END as has_storage_access,
    
    -- Access decision for API calls
    CASE 
        WHEN s.status = 'active' 
         AND COALESCE(u.api_calls_used, 0) < p.api_calls_limit
        THEN 1 
        ELSE 0 
    END as has_api_access,
    
    -- Usage percentages for warnings
    CAST(COALESCE(u.storage_used_bytes, 0) AS FLOAT) / p.storage_limit_bytes * 100 as storage_usage_percent,
    CAST(COALESCE(u.api_calls_used, 0) AS FLOAT) / p.api_calls_limit * 100 as api_usage_percent

FROM paymentservice_user_subscriptions s
LEFT JOIN paymentservice_plans p ON s.plan_id = p.id  
LEFT JOIN paymentservice_user_usage u ON s.user_id = u.user_id
WHERE s.user_id = ?
`

type CheckUserAccessRow struct {
	UserID              string
	PlanID              string
	SubscriptionStatus  string
	StorageLimitBytes   sql.NullInt64
	ApiCallsLimit       sql.NullInt64
	ComputeHoursLimit   sql.NullInt64
	PlanName            sql.NullString
	PriceCents          sql.NullInt64
	CurrentStorageBytes int64
	CurrentApiCalls     int64
	CurrentComputeHours int64
	HasStorageAccess    int64
	HasApiAccess        int64
	StorageUsagePercent int64
	ApiUsagePercent     int64
}

// Core access check query (main functionality)
func (q *Queries) CheckUserAccess(ctx context.Context, userID string) (CheckUserAccessRow, error) {
	row := q.db.QueryRowContext(ctx, checkUserAccess, userID)
	var i CheckUserAccessRow
	err := row.Scan(
		&i.UserID,
		&i.PlanID,
		&i.SubscriptionStatus,
		&i.StorageLimitBytes,
		&i.ApiCallsLimit,
		&i.ComputeHoursLimit,
		&i.PlanName,
		&i.PriceCents,
		&i.CurrentStorageBytes,
		&i.CurrentApiCalls,
		&i.CurrentComputeHours,
		&i.HasStorageAccess,
		&i.HasApiAccess,
		&i.StorageUsagePercent,
		&i.ApiUsagePercent,
	)
	return i, err
}

const createUserSubscription = `-- name: CreateUserSubscription :one
INSERT INTO paymentservice_user_subscriptions (
    id, user_id, plan_id, provider, provider_customer_id, 
    provider_subscription_id, status, current_period_start, 
    current_period_end, created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, plan_id, provider, provider_customer_id, provider_subscription_id, status, current_period_start, current_period_end, created_at, updated_at
`

type CreateUserSubscriptionParams struct {
	ID                     string
	UserID                 string
	PlanID                 string
	Provider               string
	ProviderCustomerID     sql.NullString
	ProviderSubscriptionID sql.NullString
	Status                 string
	CurrentPeriodStart     sql.NullInt64
	CurrentPeriodEnd       sql.NullInt64
	CreatedAt              int64
	UpdatedAt              int64
}

func (q *Queries) CreateUserSubscription(ctx context.Context, arg CreateUserSubscriptionParams) (PaymentserviceUserSubscription, error) {
	row := q.db.QueryRowContext(ctx, createUserSubscription,
		arg.ID,
		arg.UserID,
		arg.PlanID,
		arg.Provider,
		arg.ProviderCustomerID,
		arg.ProviderSubscriptionID,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i PaymentserviceUserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.Provider,
		&i.ProviderCustomerID,
		&i.ProviderSubscriptionID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserUsage = `-- name: CreateUserUsage :one
INSERT INTO paymentservice_user_usage (
    user_id, storage_used_bytes, api_calls_used, compute_hours_used,
    last_calculated_at, created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING user_id, storage_used_bytes, api_calls_used, compute_hours_used, last_calculated_at, created_at, updated_at
`

type CreateUserUsageParams struct {
	UserID           string
	StorageUsedBytes sql.NullInt64
	ApiCallsUsed     sql.NullInt64
	ComputeHoursUsed sql.NullInt64
	LastCalculatedAt sql.NullInt64
	CreatedAt        int64
	UpdatedAt        int64
}

func (q *Queries) CreateUserUsage(ctx context.Context, arg CreateUserUsageParams) (PaymentserviceUserUsage, error) {
	row := q.db.QueryRowContext(ctx, createUserUsage,
		arg.UserID,
		arg.StorageUsedBytes,
		arg.ApiCallsUsed,
		arg.ComputeHoursUsed,
		arg.LastCalculatedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i PaymentserviceUserUsage
	err := row.Scan(
		&i.UserID,
		&i.StorageUsedBytes,
		&i.ApiCallsUsed,
		&i.ComputeHoursUsed,
		&i.LastCalculatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActivePlans = `-- name: GetActivePlans :many
SELECT id, name, storage_limit_bytes, api_calls_limit, compute_hours_limit, price_cents, provider_price_id, is_active, created_at, updated_at FROM paymentservice_plans WHERE is_active = TRUE ORDER BY price_cents ASC
`

func (q *Queries) GetActivePlans(ctx context.Context) ([]PaymentservicePlan, error) {
	rows, err := q.db.QueryContext(ctx, getActivePlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentservicePlan
	for rows.Next() {
		var i PaymentservicePlan
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StorageLimitBytes,
			&i.ApiCallsLimit,
			&i.ComputeHoursLimit,
			&i.PriceCents,
			&i.ProviderPriceID,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlan = `-- name: GetPlan :one

SELECT id, name, storage_limit_bytes, api_calls_limit, compute_hours_limit, price_cents, provider_price_id, is_active, created_at, updated_at FROM paymentservice_plans WHERE id = ? LIMIT 1
`

// Generic Payment Service Queries (Application Agnostic)
// Plan queries
func (q *Queries) GetPlan(ctx context.Context, id string) (PaymentservicePlan, error) {
	row := q.db.QueryRowContext(ctx, getPlan, id)
	var i PaymentservicePlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StorageLimitBytes,
		&i.ApiCallsLimit,
		&i.ComputeHoursLimit,
		&i.PriceCents,
		&i.ProviderPriceID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserSubscription = `-- name: GetUserSubscription :one
SELECT id, user_id, plan_id, provider, provider_customer_id, provider_subscription_id, status, current_period_start, current_period_end, created_at, updated_at FROM paymentservice_user_subscriptions WHERE user_id = ? LIMIT 1
`

// User subscription queries (core functionality)
func (q *Queries) GetUserSubscription(ctx context.Context, userID string) (PaymentserviceUserSubscription, error) {
	row := q.db.QueryRowContext(ctx, getUserSubscription, userID)
	var i PaymentserviceUserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.Provider,
		&i.ProviderCustomerID,
		&i.ProviderSubscriptionID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserUsage = `-- name: GetUserUsage :one
SELECT user_id, storage_used_bytes, api_calls_used, compute_hours_used, last_calculated_at, created_at, updated_at FROM paymentservice_user_usage WHERE user_id = ? LIMIT 1
`

// User usage queries (core functionality)
func (q *Queries) GetUserUsage(ctx context.Context, userID string) (PaymentserviceUserUsage, error) {
	row := q.db.QueryRowContext(ctx, getUserUsage, userID)
	var i PaymentserviceUserUsage
	err := row.Scan(
		&i.UserID,
		&i.StorageUsedBytes,
		&i.ApiCallsUsed,
		&i.ComputeHoursUsed,
		&i.LastCalculatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserApiUsage = `-- name: UpdateUserApiUsage :exec
UPDATE paymentservice_user_usage 
SET api_calls_used = api_calls_used + ?, last_calculated_at = ?, updated_at = ?
WHERE user_id = ?
`

type UpdateUserApiUsageParams struct {
	ApiCallsUsed     sql.NullInt64
	LastCalculatedAt sql.NullInt64
	UpdatedAt        int64
	UserID           string
}

func (q *Queries) UpdateUserApiUsage(ctx context.Context, arg UpdateUserApiUsageParams) error {
	_, err := q.db.ExecContext(ctx, updateUserApiUsage,
		arg.ApiCallsUsed,
		arg.LastCalculatedAt,
		arg.UpdatedAt,
		arg.UserID,
	)
	return err
}

const updateUserStorageUsage = `-- name: UpdateUserStorageUsage :exec
UPDATE paymentservice_user_usage 
SET storage_used_bytes = storage_used_bytes + ?, last_calculated_at = ?, updated_at = ?
WHERE user_id = ?
`

type UpdateUserStorageUsageParams struct {
	StorageUsedBytes sql.NullInt64
	LastCalculatedAt sql.NullInt64
	UpdatedAt        int64
	UserID           string
}

func (q *Queries) UpdateUserStorageUsage(ctx context.Context, arg UpdateUserStorageUsageParams) error {
	_, err := q.db.ExecContext(ctx, updateUserStorageUsage,
		arg.StorageUsedBytes,
		arg.LastCalculatedAt,
		arg.UpdatedAt,
		arg.UserID,
	)
	return err
}

const updateUserSubscriptionProvider = `-- name: UpdateUserSubscriptionProvider :exec
UPDATE paymentservice_user_subscriptions 
SET provider_customer_id = ?, provider_subscription_id = ?, updated_at = ?
WHERE user_id = ?
`

type UpdateUserSubscriptionProviderParams struct {
	ProviderCustomerID     sql.NullString
	ProviderSubscriptionID sql.NullString
	UpdatedAt              int64
	UserID                 string
}

func (q *Queries) UpdateUserSubscriptionProvider(ctx context.Context, arg UpdateUserSubscriptionProviderParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSubscriptionProvider,
		arg.ProviderCustomerID,
		arg.ProviderSubscriptionID,
		arg.UpdatedAt,
		arg.UserID,
	)
	return err
}

const updateUserSubscriptionStatus = `-- name: UpdateUserSubscriptionStatus :exec
UPDATE paymentservice_user_subscriptions 
SET status = ?, current_period_start = ?, current_period_end = ?, updated_at = ?
WHERE user_id = ?
`

type UpdateUserSubscriptionStatusParams struct {
	Status             string
	CurrentPeriodStart sql.NullInt64
	CurrentPeriodEnd   sql.NullInt64
	UpdatedAt          int64
	UserID             string
}

func (q *Queries) UpdateUserSubscriptionStatus(ctx context.Context, arg UpdateUserSubscriptionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSubscriptionStatus,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.UpdatedAt,
		arg.UserID,
	)
	return err
}

const updateUserUsage = `-- name: UpdateUserUsage :exec
UPDATE paymentservice_user_usage 
SET storage_used_bytes = ?, api_calls_used = ?, compute_hours_used = ?,
    last_calculated_at = ?, updated_at = ?
WHERE user_id = ?
`

type UpdateUserUsageParams struct {
	StorageUsedBytes sql.NullInt64
	ApiCallsUsed     sql.NullInt64
	ComputeHoursUsed sql.NullInt64
	LastCalculatedAt sql.NullInt64
	UpdatedAt        int64
	UserID           string
}

func (q *Queries) UpdateUserUsage(ctx context.Context, arg UpdateUserUsageParams) error {
	_, err := q.db.ExecContext(ctx, updateUserUsage,
		arg.StorageUsedBytes,
		arg.ApiCallsUsed,
		arg.ComputeHoursUsed,
		arg.LastCalculatedAt,
		arg.UpdatedAt,
		arg.UserID,
	)
	return err
}
